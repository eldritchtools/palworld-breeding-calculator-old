{"version":3,"file":"static/js/998.19e430b9.chunk.js","mappings":"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","sources":["palLogic/palLogic.js","palLogic/breedingLogic.js","palLogic/findPathsWorker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { pals } from \"@eldritchtools/palworld-shared-library\";\n\nconst getPairId = (parent1, parent2) => {\n    return parent1.sortIndex < parent2.sortIndex ? (parent1.sortIndex << 10) + parent2.sortIndex : (parent2.sortIndex << 10) + parent1.sortIndex\n}\n\nconst getPalsFromPairId = (pairId) => {\n    return [indexToPal[pairId >> 10], indexToPal[pairId & ((1 << 10) - 1)]];\n}\n\nconst indexToPal = Object.values(pals).reduce((acc, pal) => {\n    acc[pal.sortIndex] = pal;\n    return acc;\n}, {})\n\n// Just a way to combine the id and the passive mask for referencing in a dict\nconst getPalMaskId = (pal, mask, passives) => {\n    return (pal.sortIndex << passives.length) + mask;\n}\n\nconst deconstructPalMaskId = (palMaskId, passives) => {\n    return [indexToPal[palMaskId >> passives.length], palMaskId & ((1 << passives.length) - 1)];\n}\n\nexport {getPairId, getPalsFromPairId, getPalMaskId, deconstructPalMaskId};","import { getPairId } from \"./palLogic\";\nimport { pals } from \"@eldritchtools/palworld-shared-library\";\n\nconst allPalsByBreedPower = Object.values(pals).sort((a, b) => a.breedingPower - b.breedingPower);\nconst idToAllBreedPowerIndex = allPalsByBreedPower.reduce((acc, pal, index) => {\n    acc[pal.id] = index;\n    return acc;\n}, {});\n\nconst breedablePalsByBreedPower = allPalsByBreedPower.filter(pal => !pal.unique);\nconst idToBreedPowerIndex = breedablePalsByBreedPower.reduce((acc, pal, index) => {\n    acc[pal.id] = index;\n    return acc;\n}, {});\n\nconst uniquePairs = Object.values(pals).reduce((acc, pal) => {\n    if (pal.parents) {\n        pal.parents.forEach(parents => {\n            const pairId = getPairId(pals[parents[0]], pals[parents[1]]);\n            if (pairId in acc) acc[pairId].push(pal.id);\n            else acc[pairId] = [pal.id];\n        });\n    }\n    return acc;\n}, {})\n\nfunction checkUniquePair(parent1, parent2) {\n    const pairId = getPairId(parent1, parent2);\n    if (pairId in uniquePairs) return uniquePairs[pairId];\n    else return null;\n}\n\nfunction computeBabyPower(parent1, parent2) {\n    // floor(x/2) is the same as x >> 1\n    return (parent1.breedingPower + parent2.breedingPower + 1) >> 1;\n}\n\nfunction comparePowerGap(babyPower, option1, option2) {\n    const diff1 = Math.abs(babyPower - option1.breedingPower);\n    const diff2 = Math.abs(babyPower - option2.breedingPower);\n    return (diff1 < diff2 || (diff1 === diff2 && option1.tiebreakIndex < option2.tiebreakIndex));\n}\n\nfunction sortPairList(list) {\n    return list.sort(([a1, a2], [b1, b2]) => {\n        if (a1.id === b1.id) return a2.sortIndex - b2.sortIndex;\n        return a1.sortIndex - b1.sortIndex;\n    })\n}\n\nfunction getChildren(parentId1, parentId2) {\n    if (parentId1 === null && parentId2 === null) {\n        return {};\n    } else if (parentId1 === null || parentId2 === null) {\n        const parent = parentId1 ? pals[parentId1] : pals[parentId2];\n        const results = {};\n        let currentIndex = 0;\n        Object.values(allPalsByBreedPower).forEach(otherParent => {\n            const uniquePair = checkUniquePair(parent, otherParent);\n            if (uniquePair) {\n                uniquePair.forEach(id => {\n                    if (id in results) results[id].push([parent, otherParent]);\n                    else results[id] = [[parent, otherParent]];\n                })\n                return;\n            }\n\n            const babyPower = computeBabyPower(parent, otherParent);\n            while (currentIndex < breedablePalsByBreedPower.length - 1 && !comparePowerGap(babyPower, breedablePalsByBreedPower[currentIndex], breedablePalsByBreedPower[currentIndex + 1])) {\n                currentIndex++;\n            }\n            if (breedablePalsByBreedPower[currentIndex].id in results) results[breedablePalsByBreedPower[currentIndex].id].push([parent, otherParent]);\n            else results[breedablePalsByBreedPower[currentIndex].id] = [[parent, otherParent]];\n        })\n\n        return Object.entries(results).reduce((acc, [id, pairs]) => {\n            acc[id] = sortPairList(pairs);\n            return acc;\n        }, {})\n    } else {\n        const parent1 = pals[parentId1];\n        const parent2 = pals[parentId2];\n        if (parent1.sortIndex === parent2.sortIndex) return { [parent1.id]: [[parent1, parent2]] };\n        const uniquePair = checkUniquePair(parent1, parent2);\n        if (uniquePair) return uniquePair.reduce((acc, id) => { acc[id] = [[parent1, parent2]]; return acc }, {});\n        const babyPower = computeBabyPower(parent1, parent2);\n        // binary search with left and right ends starting at the index of the parents since the child is always between them\n        // use the left and right ends if the parent isn't in the list\n        let L, R = null;\n        if (parent1.breedingPower < parent2.breedingPower) {\n            L = parent1.unique ? 0 : idToBreedPowerIndex[parent1.id];\n            R = parent2.unique ? breedablePalsByBreedPower.length - 1 : idToBreedPowerIndex[parent2.id];\n        } else {\n            L = parent2.unique ? 0 : idToBreedPowerIndex[parent2.id];\n            R = parent1.unique ? breedablePalsByBreedPower.length - 1 : idToBreedPowerIndex[parent1.id];\n        }\n\n        while (R - L > 2) {\n            let M = (R + L) >> 1;\n            if (breedablePalsByBreedPower[M].breedingPower < babyPower) L = M;\n            else R = M;\n        }\n\n        let best = L;\n        for (let i = L + 1; i <= R; i++) {\n            if (comparePowerGap(babyPower, breedablePalsByBreedPower[i], breedablePalsByBreedPower[best])) best = i;\n        }\n\n        return { [breedablePalsByBreedPower[best].id]: [[parent1, parent2]] };\n    }\n}\n\nfunction getParentPairs(childId, sorted = true) {\n    if (!childId) return [];\n    const child = pals[childId];\n    if (child.unique) {\n        return sortPairList([...child.parents.map(parents => parents.map(p => pals[p]))]);\n    } else {\n        // the possible partners of every pal to produce the same child is a sliding window\n        const pairs = [];\n        const bpi = idToBreedPowerIndex[child.id];\n        const notFirst = bpi !== 0;\n        const notLast = bpi !== Object.keys(idToBreedPowerIndex).length - 1;\n        let si = idToAllBreedPowerIndex[child.id]; // starting index of \"sliding window\"\n        for (let p1 = si; p1 >= 0; p1--) {\n            for (let p2 = si; p2 < allPalsByBreedPower.length; p2++) {\n                const babyPower = computeBabyPower(allPalsByBreedPower[p1], allPalsByBreedPower[p2]);\n                const selfDiff = Math.abs(babyPower - child.breedingPower);\n\n                if (notFirst) {\n                    // move the starting index of the window forward if the pal in the current start is no longer part of it\n                    const otherDiff = Math.abs(babyPower - breedablePalsByBreedPower[bpi - 1].breedingPower);\n                    if (otherDiff < selfDiff || (otherDiff === selfDiff && breedablePalsByBreedPower[bpi - 1].tiebreakIndex < child.tiebreakIndex)) {\n                        si++;\n                        continue;\n                    }\n                }\n\n                if (notLast) {\n                    // this is the end of the window for this parent\n                    const otherDiff = Math.abs(babyPower - breedablePalsByBreedPower[bpi + 1].breedingPower);\n                    if (otherDiff < selfDiff || (otherDiff === selfDiff && breedablePalsByBreedPower[bpi + 1].tiebreakIndex < child.tiebreakIndex)) {\n                        break;\n                    }\n                }\n\n                const parent1 = allPalsByBreedPower[p1];\n                const parent2 = allPalsByBreedPower[p2];\n                if (parent1.sortIndex < parent2.sortIndex) pairs.push([parent1, parent2]);\n                else pairs.push([parent2, parent1]);\n            }\n        }\n\n        if (sorted)\n            return sortPairList(pairs);\n        else\n            return pairs;\n    }\n}\n\nfunction getPalsByLayer(profileData) {\n    const palSteps = {};\n    const queue = [];\n    let queueIndex = 0;\n\n    const palsByLayer = {};\n    \n    Object.keys(profileData.pals).forEach(palId => {\n        palSteps[palId] = 0;\n        queue.push(palId);\n    });\n\n    while (queueIndex < queue.length) {\n        const palId = queue[queueIndex++];\n        const pal = pals[palId];\n\n        // check all possible pairs with the current pal as one of the parents\n        let currentIndex = 0;\n        Object.values(allPalsByBreedPower).forEach(otherParent => {\n            if (!(otherParent.id in palSteps)) return;\n            if (palId === otherParent.id) return;\n\n            // check if it's a unique pair, if not breed normally\n            let children = checkUniquePair(pal, otherParent);\n            if (!children) {\n                const babyPower = computeBabyPower(pal, otherParent);\n                // since we're iterating in order of breed power, the possible child will also always be in the same order if it's not a unique pair\n                while (currentIndex < breedablePalsByBreedPower.length - 1 && !comparePowerGap(babyPower, breedablePalsByBreedPower[currentIndex], breedablePalsByBreedPower[currentIndex + 1])) {\n                    currentIndex++;\n                }\n                children = [breedablePalsByBreedPower[currentIndex].id];\n            }\n\n            children.forEach(childId => {\n                if (childId in palSteps) return;\n\n                const steps = Math.max(palSteps[palId], palSteps[otherParent.id]) + 1;\n                palSteps[childId] = steps;\n                \n                if (!(steps in palsByLayer)) palsByLayer[steps] = {};\n                palsByLayer[steps][childId] = [pal, otherParent];\n                queue.push(childId);\n            });\n        })\n    }\n\n    return palsByLayer;\n}\n\nexport { allPalsByBreedPower, idToAllBreedPowerIndex, breedablePalsByBreedPower, idToBreedPowerIndex, uniquePairs, checkUniquePair, computeBabyPower, comparePowerGap };\nexport { getChildren, getParentPairs, getPalsByLayer };","import PriorityQueue from \"js-priority-queue\";\nimport { deconstructPalMaskId, getPalMaskId } from \"./palLogic\";\nimport { pals } from \"@eldritchtools/palworld-shared-library\";\n\nimport {\n    allPalsByBreedPower,\n    breedablePalsByBreedPower,\n    checkUniquePair,\n    computeBabyPower,\n    comparePowerGap,\n    getParentPairs\n} from './breedingLogic';\n\nconst SEARCH_CHUNK_LIMIT = 50;\n\n/* eslint-disable no-restricted-globals */\nself.onmessage = function (e) {\n    const { command, params } = e.data;\n    if (command === \"start\") {\n        findPaths(params);\n    } else if (command === \"cancel\") {\n        cancelled = true;\n    }\n};\n\nlet cancelled = false;\n\nfunction findPaths({ targetChildId, targetPassives, profileData, searchBeamSize, costThreshold }) {\n    if (!targetChildId) return { candidatePaths: [], suggestedPals: [] };\n    cancelled = false;\n\n    // bitmask of passives of each starting pal\n    const passiveMasks = Object.entries(profileData.pals).reduce((acc, [id, passives]) => {\n        let mask = 0;\n        for (let i = 0; i < targetPassives.length; i++) {\n            if (passives.includes(targetPassives[i])) {\n                mask |= (1 << i);\n            }\n        }\n        acc[id] = mask;\n        return acc;\n    }, {});\n\n    // data structs for the beam search bfs\n    const queue = new PriorityQueue({ comparator: (a, b) => a.cost - b.cost });\n    const bests = {}\n    const visited = {};\n    const targetBests = [];\n    const targetMask = (1 << targetPassives.length) - 1;\n    bests[getPalMaskId(pals[targetChildId], targetMask, targetPassives)] = targetBests;\n    const targetBestsLimit = 100 * searchBeamSize;\n    let batch = [];\n\n    // insert a candidate node into 'bests', returns the resulting state if success, null otherwise\n    // if the candidate is to the target, insert it and return the state\n    const insertCandidate = (cost, pal, mask, path, goal = false) => {\n        const palMaskId = getPalMaskId(pal, mask, targetPassives);\n        if (goal) {\n            const state = { cost, pal, mask, path };\n            if (palMaskId in bests) bests[palMaskId].push(state);\n            else bests[palMaskId] = [state];\n            batch.push(state);\n            return state;\n        }\n        if (palMaskId in bests) {\n            if (bests[palMaskId].length < searchBeamSize || cost < bests[palMaskId][bests[palMaskId].length - 1].cost) {\n                const state = { cost, pal, mask, path };\n                bests[palMaskId].push(state);\n                bests[palMaskId].sort((a, b) => a.cost - b.cost);\n                visited[palMaskId] = false;\n                if (pal.id !== targetChildId && bests[palMaskId].length > searchBeamSize) {\n                    bests[palMaskId].length = searchBeamSize;\n                }\n                return state;\n            }\n        } else {\n            const state = { cost, pal, mask, path }\n            bests[palMaskId] = [state];\n            visited[palMaskId] = false;\n            return state;\n        }\n        return null;\n    }\n\n    // insert all initially available pals as starting nodes\n    Object.keys(profileData.pals).forEach(id => {\n        const state = insertCandidate(0, pals[id], passiveMasks[id], {})\n        if (state) queue.queue(state);\n    });\n\n    // search step chunk to yield to incoming messages in case of cancelling\n    const handleSearchChunk = () => {\n        // beam search bfs/dijkstra, early quit when enough candidates have been found or the computation was aborted\n        let counter = 0;\n        while (queue.length > 0 && targetBests.length < targetBestsLimit && !cancelled && counter < SEARCH_CHUNK_LIMIT) {\n            counter++;\n            const state = queue.dequeue();\n            const { pal, mask, path } = state;\n            const statePalMaskId = getPalMaskId(pal, mask, targetPassives);\n            if (!bests[statePalMaskId].includes(state)) continue;\n            visited[statePalMaskId] = true;\n\n            // check all possible pairs with the current pal as one of the parents\n            let currentIndex = 0;\n            /* eslint-disable no-loop-func */\n            Object.values(allPalsByBreedPower).forEach(otherParent => {\n                if (otherParent.id === targetChildId) return;\n\n                // ignore if the limit has been reached or the computation was aborted\n                if (targetBests.length >= targetBestsLimit && !cancelled)\n                    return;\n\n                // check if it's a unique pair, if not breed normally\n                let children = checkUniquePair(pal, otherParent);\n                if (!children && pal.id === otherParent.id) children = [pal.id];\n                if (!children) {\n                    const babyPower = computeBabyPower(pal, otherParent);\n                    // since we're iterating in order of breed power, the possible child will also always be in the same order if it's not a unique pair\n                    while (currentIndex < breedablePalsByBreedPower.length - 1 && !comparePowerGap(babyPower, breedablePalsByBreedPower[currentIndex], breedablePalsByBreedPower[currentIndex + 1])) {\n                        currentIndex++;\n                    }\n                    children = [breedablePalsByBreedPower[currentIndex].id];\n                }\n\n                children.forEach(childId => {\n                    // need to do this check for all possible masks of the other parent\n                    for (let otherMask = 0; otherMask < (1 << targetPassives.length); otherMask++) {\n                        const palMaskId = getPalMaskId(otherParent, otherMask, targetPassives);\n                        // Only consider visited states to prevent doubling and invalid paths\n                        if (!visited[palMaskId]) continue;\n\n                        const newMask = (childId in passiveMasks ? passiveMasks[childId] : 0) | mask | otherMask;\n                        const childPalMaskId = getPalMaskId(pals[childId], newMask, targetPassives);\n                        // If the child pal was a needed breed in this pal's path, then ignore this to prevent circular breed paths\n                        if (childPalMaskId in path) continue;\n\n                        // if the resulting pal was already available from the start and its passive list is a superset of that of both parents then there's no point in breeding them\n                        // technically there is if the passives are more isolated in the parents, but that's just a limitation of this tool\n                        if (childId in profileData.pals && (passiveMasks[childId] | mask | otherMask) === passiveMasks[childId]) continue;\n\n                        // If both parents are the same and one mask is the subset of another, then there's no point in breeding them\n                        // It is relevant to check this and not to just ignore all cases of the same parents because there may be cases of a pal\n                        // needing to be bred with two different sets of passives under two different pairs of parents, then combined to get the final passives\n                        if (pal.id === otherParent.id && ((mask | otherMask) === mask || (mask | otherMask) === otherMask)) continue;\n\n                        let otherStates = null;\n                        if (otherParent.id in profileData.pals) {\n                            // if the other parent is an already available pal, only consider masks that are not strictly subsets of its initial mask\n                            if ((otherMask | passiveMasks[otherParent.id]) === passiveMasks[otherParent.id] && otherMask !== passiveMasks[otherParent.id]) continue;\n                            // check if this configuration is available get its best states\n                            if (palMaskId in bests) otherStates = bests[palMaskId];\n                        } else {\n                            // if the other parent was also bred, get its best states if available\n                            if (palMaskId in bests) otherStates = bests[palMaskId];\n                        }\n                        // only propagate if the other parent was available\n                        if (!otherStates) continue;\n\n                        otherStates.forEach(otherState => {\n                            // If the child pal was a needed breed in the other path, then ignore this to prevent circular breed paths\n                            if (childPalMaskId in otherState.path) return;\n\n                            // merge passive masks of parents with mask of child if it's already available\n\n                            const newPath = { ...path, ...otherState.path, [childPalMaskId]: [[pal, mask], [otherParent, otherMask]] };\n\n                            if (childId === targetChildId && newMask === (1 << targetPassives.length) - 1) {\n                                // inserting a candidate for the goal\n                                insertCandidate(Object.keys(newPath).length, pals[childId], newMask, newPath, true);\n                            } else {\n                                // inserting a candidate for further exploration\n                                const newState = insertCandidate(Object.keys(newPath).length, pals[childId], newMask, newPath);\n                                if (newState) queue.queue(newState);\n                            }\n                        });\n                    }\n                });\n            })\n        }\n\n        if (batch.length > 0) {\n            self.postMessage({ type: \"batch\", results: batch });\n            batch.length = 0;\n        }\n\n        if (queue.length === 0 || targetBests.length >= targetBestsLimit || cancelled) {\n            // legitimately ended\n            // sort just in case\n            targetBests.sort((a, b) => a.cost - b.cost);\n\n            // find recommended capture pals by exploring all candidate paths collected at the target\n            const explored = new Set();\n            const scores = {};\n\n            const addScore = (pal, saving, finalCost) => {\n                if (pal.id in profileData.pals) return;\n                if (pal.id in scores) scores[pal.id] += saving / (1 + 3 * finalCost);\n                else scores[pal.id] = saving / (1 + 3 * finalCost);\n            }\n\n            if (targetBests.length > 0) {\n                targetBests.forEach(({ cost, path }) => {\n                    Object.entries(path).forEach(([palMaskId, [[p1, m1], [p2, m2]]]) => {\n                        const [child, mask] = deconstructPalMaskId(palMaskId, targetPassives);\n\n                        // consider cases where one parent is a capture pal\n                        const cost1 = bests[getPalMaskId(p1, m1, targetPassives)][0].cost;\n                        const cost2 = bests[getPalMaskId(p2, m2, targetPassives)][0].cost;\n                        if (m2 === mask && !(p2.id in profileData.pals)) addScore(p2, cost1, cost - cost1);\n                        if (m1 === mask && !(p1.id in profileData.pals)) addScore(p1, cost2, cost - cost2);\n\n                        // skip exploration of parent combinations if this state was already previously explored\n                        if (explored.has(palMaskId)) return;\n                        explored.add(palMaskId);\n\n                        getParentPairs(child.id, false).forEach(([parent1, parent2]) => {\n                            const bests1 = bests[getPalMaskId(parent1, mask, targetPassives)];\n                            const bests2 = bests[getPalMaskId(parent2, mask, targetPassives)];\n\n                            // if the path of one parent is within the cost threshold and the other is not initially available, score the unavailable pal\n                            // technically also checking for the unavailable pal in the path would be correct, but that seems unnecessary for the added complexity \n                            if (bests1 && bests1[0].cost <= costThreshold && !(parent2.id in profileData.pals)) addScore(parent2, costThreshold, cost - costThreshold);\n                            if (bests2 && bests2[0].cost <= costThreshold && !(parent1.id in profileData.pals)) addScore(parent1, costThreshold, cost - costThreshold);\n                        })\n                    })\n                });\n            } else {\n                // If the child is unreachable, check all direct parents to see if it can be salvaged by catching a pal\n                getParentPairs(targetChildId, false).forEach(([parent1, parent2]) => {\n                    const bests1 = bests[getPalMaskId(parent1, targetMask, targetPassives)];\n                    const bests2 = bests[getPalMaskId(parent2, targetMask, targetPassives)];\n\n                    // if the path of one parent is within the cost threshold and the other is not initially available, score the unavailable pal\n                    // technically also checking for the unavailable pal in the path would be correct, but that seems unnecessary for the added complexity\n                    if (bests1 && bests1.length > 0 && bests1[0].cost <= costThreshold && !(parent2.id in profileData.pals)) addScore(parent2, costThreshold, bests1[0].cost);\n                    if (bests2 && bests2.length > 0 && bests2[0].cost <= costThreshold && !(parent1.id in profileData.pals)) addScore(parent1, costThreshold, bests2[0].cost);\n                })\n            }\n\n            // sort suggested pals by decreasing score\n            const result = { candidatePaths: targetBests, suggestedPals: Object.keys(scores).sort((a, b) => scores[b] - scores[a]).map(a => pals[a]) };\n            self.postMessage({ type: \"done\", results: result, cancelled: cancelled });\n        } else {\n            // just ended due to chunk\n            setTimeout(handleSearchChunk, 0);\n        }\n    }\n\n    handleSearchChunk();\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [800], () => (__webpack_require__(8998)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"9f69be2a\" + \".chunk.js\";\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/palworld-breeding-calculator-old/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t998: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkpalworld_breeding_calculator_old\"] = self[\"webpackChunkpalworld_breeding_calculator_old\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(800).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["getPairId","parent1","parent2","sortIndex","indexToPal","Object","values","pals","reduce","acc","pal","getPalMaskId","mask","passives","length","allPalsByBreedPower","sort","a","b","breedingPower","idToAllBreedPowerIndex","index","id","breedablePalsByBreedPower","filter","unique","idToBreedPowerIndex","uniquePairs","parents","forEach","pairId","push","checkUniquePair","computeBabyPower","comparePowerGap","babyPower","option1","option2","diff1","Math","abs","diff2","tiebreakIndex","sortPairList","list","_ref","_ref2","a1","a2","b1","b2","getParentPairs","childId","sorted","arguments","undefined","child","map","p","pairs","bpi","notFirst","notLast","keys","si","p1","p2","selfDiff","otherDiff","self","onmessage","e","command","params","data","targetChildId","targetPassives","profileData","searchBeamSize","costThreshold","candidatePaths","suggestedPals","cancelled","passiveMasks","entries","i","includes","queue","PriorityQueue","comparator","cost","bests","visited","targetBests","targetMask","targetBestsLimit","batch","insertCandidate","path","goal","palMaskId","state","handleSearchChunk","counter","dequeue","statePalMaskId","currentIndex","otherParent","children","otherMask","newMask","childPalMaskId","otherStates","otherState","newPath","_objectSpread","newState","postMessage","type","results","explored","Set","scores","addScore","saving","finalCost","_ref3","_ref4","m1","m2","deconstructPalMaskId","cost1","cost2","has","add","_ref5","bests1","bests2","_ref6","result","setTimeout","findPaths","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","key","splice","r","n","getter","__esModule","d","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}